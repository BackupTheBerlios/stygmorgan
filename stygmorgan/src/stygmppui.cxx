// generated by Fast Light User Interface Designer (fluid) version 1.0107

#include "stygmppui.h"
//Copyright(c) 2006 Josep Andreu (holborn)
//License GNU/GPL version 2
#include <Fl/Fl_Check_Button.H>

void rmgmpp::cb_rmgmppwin_i(Fl_Double_Window*, void*) {
  pera=2;
rmgmppwin->hide();
rmgmo->wpatterneditor=0;
rmgmppwin->clear();
delete rmgmppwin;
}
void rmgmpp::cb_rmgmppwin(Fl_Double_Window* o, void* v) {
  ((rmgmpp*)(o->user_data()))->cb_rmgmppwin_i(o,v);
}

void rmgmpp::cb_Cancel_i(Fl_Button*, void*) {
  rmgmo->bcancel=1;
rmgmppwin->do_callback();
}
void rmgmpp::cb_Cancel(Fl_Button* o, void* v) {
  ((rmgmpp*)(o->parent()->user_data()))->cb_Cancel_i(o,v);
}

void rmgmpp::cb_Ok_i(Fl_Button*, void*) {
  calcula();
rmgmppwin->do_callback();
}
void rmgmpp::cb_Ok(Fl_Button* o, void* v) {
  ((rmgmpp*)(o->parent()->user_data()))->cb_Ok_i(o,v);
}

void rmgmpp::cb_PatChoice_i(Fl_Choice* o, void*) {
  ASeCh((int)o->value());
}
void rmgmpp::cb_PatChoice(Fl_Choice* o, void* v) {
  ((rmgmpp*)(o->parent()->user_data()))->cb_PatChoice_i(o,v);
}

void rmgmpp::cb_DChannel_i(Fl_Counter* o, void*) {
  rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[(int)PatChoice->value()].Canal=(int)o->value()-1;
}
void rmgmpp::cb_DChannel(Fl_Counter* o, void* v) {
  ((rmgmpp*)(o->parent()->user_data()))->cb_DChannel_i(o,v);
}

void rmgmpp::cb_ChordRoot_i(Fl_Counter* o, void*) {
  DChordRoot->copy_label(rmgmo->NC[(int)o->value()].Nom);
rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[(int)PatChoice->value()].ChRoot=(int)o->value();
}
void rmgmpp::cb_ChordRoot(Fl_Counter* o, void* v) {
  ((rmgmpp*)(o->parent()->user_data()))->cb_ChordRoot_i(o,v);
}

void rmgmpp::cb_ChordType_i(Fl_Counter* o, void*) {
  DChordType->copy_label(rmgmo->ChN[(int)o->value()].Nom);
rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[(int)PatChoice->value()].ChType=(int)o->value();
}
void rmgmpp::cb_ChordType(Fl_Counter* o, void* v) {
  ((rmgmpp*)(o->parent()->user_data()))->cb_ChordType_i(o,v);
}

void rmgmpp::cb_NTT_i(Fl_Counter* o, void*) {
  rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[(int)PatChoice->value()].NTT=(int)o->value();
}
void rmgmpp::cb_NTT(Fl_Counter* o, void* v) {
  ((rmgmpp*)(o->parent()->user_data()))->cb_NTT_i(o,v);
}

void rmgmpp::cb_RTR_i(Fl_Counter* o, void*) {
  rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[(int)PatChoice->value()].RTR=(int)o->value();
}
void rmgmpp::cb_RTR(Fl_Counter* o, void* v) {
  ((rmgmpp*)(o->parent()->user_data()))->cb_RTR_i(o,v);
}

rmgmpp::rmgmpp(RMGMO *rmgmo_) {
  char temp[128];
static const char *pepe [] ={"stygmorgan"};

int argc=1;
char **argv= (char **) pepe;
Fl::visual(FL_DOUBLE|FL_INDEX);
Fl::visual(FL_RGB);
rmgmo=rmgmo_;
make_window();
rmgmppwin->position(x,y);
bzero(temp,sizeof(temp));
sprintf(temp, "%s %s - %s - %s - Pattern Parameters",PACKAGE,VERSION,rmgmo->nStyle.Name,rmgmo->nStyle.Pattern[rmgmo->Variacion].Name);
rmgmppwin->label(temp);
rmgmppwin->icon((char *)p);
rmgmppwin->show(argc,argv);
}

Fl_Double_Window* rmgmpp::make_window() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = rmgmppwin = new Fl_Double_Window(830, 335);
    w = o;
    o->color(FL_BACKGROUND2_COLOR);
    o->callback((Fl_Callback*)cb_rmgmppwin, (void*)(this));
    { Fl_Button* o = new Fl_Button(735, 275, 80, 25, "Cancel");
      o->callback((Fl_Callback*)cb_Cancel);
    }
    { Fl_Button* o = new Fl_Button(735, 305, 80, 25, "Ok");
      o->callback((Fl_Callback*)cb_Ok);
    }
    { Fl_Choice* o = PatChoice = new Fl_Choice(10, 25, 150, 25, "Original Channel/Track");
      o->down_box(FL_BORDER_BOX);
      o->labelsize(11);
      o->callback((Fl_Callback*)cb_PatChoice);
      o->align(FL_ALIGN_TOP_LEFT);
    }
    { Fl_Counter* o = DChannel = new Fl_Counter(10, 75, 100, 25, "Dest. Channel");
      o->type(1);
      o->box(FL_PLASTIC_DOWN_BOX);
      o->labelsize(11);
      o->minimum(1);
      o->maximum(16);
      o->step(1);
      o->value(1);
      o->callback((Fl_Callback*)cb_DChannel);
      o->align(FL_ALIGN_TOP_LEFT);
    }
    { Fl_Counter* o = ChordRoot = new Fl_Counter(10, 120, 100, 25, "Chord Root");
      o->type(1);
      o->box(FL_PLASTIC_DOWN_BOX);
      o->labelsize(11);
      o->minimum(1);
      o->maximum(12);
      o->step(1);
      o->value(1);
      o->callback((Fl_Callback*)cb_ChordRoot);
      o->align(FL_ALIGN_TOP_LEFT);
    }
    { Fl_Counter* o = ChordType = new Fl_Counter(10, 165, 100, 25, "Chord Type");
      o->type(1);
      o->box(FL_PLASTIC_DOWN_BOX);
      o->labelsize(11);
      o->minimum(0);
      o->maximum(32);
      o->step(1);
      o->value(1);
      o->callback((Fl_Callback*)cb_ChordType);
      o->align(FL_ALIGN_TOP_LEFT);
    }
    { Fl_Box* o = DChordRoot = new Fl_Box(120, 120, 90, 30);
      o->box(FL_DOWN_BOX);
      o->labelcolor((Fl_Color)1);
    }
    { Fl_Box* o = DChordType = new Fl_Box(120, 165, 90, 30);
      o->box(FL_DOWN_BOX);
      o->labelcolor((Fl_Color)1);
    }
    { Fl_Counter* o = NTT = new Fl_Counter(10, 210, 100, 25, "NTT");
      o->type(1);
      o->box(FL_PLASTIC_DOWN_BOX);
      o->labelsize(11);
      o->minimum(1);
      o->maximum(12);
      o->step(1);
      o->value(1);
      o->callback((Fl_Callback*)cb_NTT);
      o->align(FL_ALIGN_TOP_LEFT);
    }
    { Fl_Counter* o = RTR = new Fl_Counter(10, 255, 100, 25, "RTR");
      o->type(1);
      o->box(FL_PLASTIC_DOWN_BOX);
      o->labelsize(11);
      o->minimum(1);
      o->maximum(12);
      o->step(1);
      o->value(1);
      o->callback((Fl_Callback*)cb_RTR);
      o->align(FL_ALIGN_TOP_LEFT);
    }
    { Fl_Box* o = new Fl_Box(215, 20, 610, 245);
      o->box(FL_DOWN_BOX);
      o->color(FL_BACKGROUND2_COLOR);
    }
    o->end();
  }
  int i,j,k,l,udata;
char temp[64];
char pep[64];

for (i=0; i<rmgmo->nStyle.Pattern[rmgmo->Variacion].numcasm; i++)
{
bzero(pep,sizeof(pep));
for (j=0;j<(int)strlen(rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[i].Name);j++)
if (rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[i].Name[j]!=47)pep[j]=rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[i].Name[j];
bzero(temp,sizeof(temp));
sprintf(temp ,"%d_%s",rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[i].track+1,pep);
PatChoice->add(temp);
}

PatChoice->value(0);
k=0;
l=0;
udata=100;
for(j=0; j<=4; j++)
 {

for (i=0;i<8; i++)
 {

 switch (i)
    {
      case 1:
          l=90;   
          break;
      default:
          l=75;
    }
    
                
Fl_Check_Button *obot = new Fl_Check_Button(230+i*l, 50+j*45, 45, 25,rmgmo->ChN[k].Nom);
      obot->down_box(FL_DOWN_BOX);
      obot->align(FL_ALIGN_TOP_LEFT);
      obot->labelcolor((Fl_Color)4);
      obot->user_data((void*) udata);
      
k++;
udata=100+k;

rmgmppwin->add(obot);

if ((j==4) && (i==1)) break;
}

}

ASeCh(0);
  return w;
}

void rmgmpp::ASeCh(int tr) {
  int i,j;
unsigned long lolo=0;
Fl_Check_Button *pepe;

DChannel->value(rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[tr].Canal+1);
ChordRoot->value(rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[tr].ChRoot);
ChordType->value(rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[tr].ChType);
ChordRoot->do_callback();
ChordType->do_callback();
NTT->value(rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[tr].NTT);
RTR->value(rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[tr].RTR);

for(i=0; i<33; i++)
{

if (i==0) lolo = 1; else 
for (j=1; j<=i; j++) lolo *=2;
pepe = (Fl_Check_Button*) rmgmppwin->child(11+i);
if ( (rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[tr].ChM & lolo) == lolo) pepe->value(1); else pepe->value(0); 
   
}
}

void rmgmpp::calcula() {
  int i,j;
unsigned long tito=0;
unsigned long lolo=0;
Fl_Check_Button *pepe;

for(i=0; i<33; i++)
{

if (i==0) lolo = 1; else 
for (j=1; j<=i; j++) lolo *=2;

pepe = (Fl_Check_Button*) rmgmppwin->child(11+i);

if ((int) pepe->value() == 1) tito +=lolo;

}

rmgmo->nStyle.Pattern[rmgmo->Variacion].casm[(int)PatChoice->value()].ChM=tito;
}
