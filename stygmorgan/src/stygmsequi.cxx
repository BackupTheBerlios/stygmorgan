// generated by Fast Light User Interface Designer (fluid) version 1.0107

#include <libintl.h>
#include "stygmsequi.h"
//Copyright(c) 2006 Josep Andreu (holborn)
//License GNU/GPL version 2
//Based on gmorgan

ElScroll::ElScroll(int X, int Y, int W, int H, const char* L) : Fl_Scroll(X,Y,W,H,L) {
}

void ElScroll::resize(int X, int Y,int W, int H) {
  int kx,ky;
int p=0;
int q=0;
kx=(W-20)/4;
ky=(H-20)/6;

for ( int t=0; t<children(); t++ ) 
  {          
    Fl_Widget *w = child(t);
    
    long long temp = (long long) w->user_data();
    
    if ((int) temp > 0)
     {
     w->resize((kx*p)+1 ,(ky*q)+1,kx,ky);
     p++;
     if (p==4) 
     {
      p=0;
      q++;
     } 
     }
  }
         
  init_sizes();
  Fl_Scroll::resize(X,Y,W,H);
}

void sequencer::cb_stygmseqwin_i(Fl_Double_Window*, void*) {
  GuardaPrefs();

rmgmo->bcancel=2;
pera=2;
Fl::remove_timeout(tick);
rmgmo->ctipo=2;
rmgmo->fundi=0;
rmgmo->splay=0;
rmgmo->bass=0;
rmgmo->wsequencer=0;
stygmseqwin->clear();
stygmseqwin->hide();
delete stygmseqwin;
}
void sequencer::cb_stygmseqwin(Fl_Double_Window* o, void* v) {
  ((sequencer*)(o->user_data()))->cb_stygmseqwin_i(o,v);
}

void sequencer::cb_New_i(Fl_Menu_*, void*) {
  NewSong();
}
void sequencer::cb_New(Fl_Menu_* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_New_i(o,v);
}

void sequencer::cb_Load_i(Fl_Menu_*, void*) {
  char *filename;
filename=fl_file_chooser("Load Song:","(*.stysong)",NULL,0);
if (filename==NULL) return;
filename=fl_filename_setext(filename,".stysong");
rmgmo->loadsong(filename);
Titulo->value(SongF.title);
STempo->value(SongF.bpm);
Slider->value(1);
Slider->do_callback();
MTempoTrack->value(SongF.MasterT);
GeneraScroll();
labelwin();
}
void sequencer::cb_Load(Fl_Menu_* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Load_i(o,v);
}

void sequencer::cb_Save_i(Fl_Menu_*, void*) {
  char *filename;
#define EXT ".stysong"
filename=fl_file_chooser("Save Song:","(*"EXT")",NULL,0);
if (filename==NULL) return;
filename=fl_filename_setext(filename,EXT);
#undef EXT
SongF.bpm=(int)STempo->value();
rmgmo->savesong(filename);
}
void sequencer::cb_Save(Fl_Menu_* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Save_i(o,v);
}

void sequencer::cb_Export_i(Fl_Menu_*, void*) {
  if (CheckForExport()) return;

char *filename;
#define EXT ".mid"
filename=fl_file_chooser("Export to Midi File:","(*"EXT")",NULL,0);
if (filename==NULL) return;
filename=fl_filename_setext(filename,EXT);
#undef EXT
rmgmo->saveMidiFile(filename);
rmgmo->cas=1;
}
void sequencer::cb_Export(Fl_Menu_* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Export_i(o,v);
}

void sequencer::cb_Close_i(Fl_Menu_*, void*) {
  stygmseqwin->do_callback();
}
void sequencer::cb_Close(Fl_Menu_* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Close_i(o,v);
}

void sequencer::cb_Copy_i(Fl_Menu_*, void*) {
  PreparaEdit(1);
}
void sequencer::cb_Copy(Fl_Menu_* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Copy_i(o,v);
}

void sequencer::cb_Delete_i(Fl_Menu_*, void*) {
  PreparaEdit(2);
}
void sequencer::cb_Delete(Fl_Menu_* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Delete_i(o,v);
}

void sequencer::cb_Move_i(Fl_Menu_*, void*) {
  PreparaEdit(3);
}
void sequencer::cb_Move(Fl_Menu_* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Move_i(o,v);
}

void sequencer::cb_Tempo_i(Fl_Menu_*, void*) {
  prepara_WTT();
WTT->hide();
WTT->position(x+30,y+30);
prepara_WTT();

static const char *pepe [] ={"stygmorgan"};

int argc=1;
char **argv= (char **) pepe;

WTT->icon((char *)p);

WTT->show(argc,argv);
}
void sequencer::cb_Tempo(Fl_Menu_* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Tempo_i(o,v);
}

void sequencer::cb_Help_i(Fl_Menu_*, void*) {
  rmgmo->ventana=7;
}
void sequencer::cb_Help(Fl_Menu_* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Help_i(o,v);
}

void sequencer::cb_About_i(Fl_Menu_*, void*) {
  if(wabout) return;
wabout=1;
rmgmo->ventana=1;
}
void sequencer::cb_About(Fl_Menu_* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_About_i(o,v);
}

Fl_Menu_Item sequencer::menu_[] = {
 {gettext("&File"), 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {gettext("New"), 0,  (Fl_Callback*)sequencer::cb_New, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {gettext("Load Song"), 0,  (Fl_Callback*)sequencer::cb_Load, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {gettext("Save Song"), 0,  (Fl_Callback*)sequencer::cb_Save, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {gettext("Export Midi File"), 0,  (Fl_Callback*)sequencer::cb_Export, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {gettext("Close"), 0,  (Fl_Callback*)sequencer::cb_Close, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {gettext("&Edit"), 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {gettext("Copy"), 0,  (Fl_Callback*)sequencer::cb_Copy, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {gettext("Delete"), 0,  (Fl_Callback*)sequencer::cb_Delete, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {gettext("Move"), 0,  (Fl_Callback*)sequencer::cb_Move, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {gettext("Tempo Track"), 0,  (Fl_Callback*)sequencer::cb_Tempo, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {gettext("&Help"), 0,  0, 0, 64, FL_NORMAL_LABEL, 0, 14, 0},
 {gettext("Help"), 0xffbe,  (Fl_Callback*)sequencer::cb_Help, 0, 128, FL_NORMAL_LABEL, 0, 14, 0},
 {gettext("About"), 0,  (Fl_Callback*)sequencer::cb_About, 0, 0, FL_NORMAL_LABEL, 0, 14, 0},
 {0,0,0,0,0,0,0,0,0},
 {0,0,0,0,0,0,0,0,0}
};

void sequencer::cb_Titulo_i(Fl_Input* o, void*) {
  strcpy(SongF.title,o->value());
labelwin();
}
void sequencer::cb_Titulo(Fl_Input* o, void* v) {
  ((sequencer*)(o->parent()->parent()->user_data()))->cb_Titulo_i(o,v);
}

void sequencer::cb_STempo_i(Fl_Value_Input* o, void*) {
  SongF.bpm=(int)o->value();
rmgmo->bpm=SongF.bpm;
rmgmo->set_tempo();
}
void sequencer::cb_STempo(Fl_Value_Input* o, void* v) {
  ((sequencer*)(o->parent()->parent()->user_data()))->cb_STempo_i(o,v);
}

void sequencer::cb__i(Fl_Button*, void*) {
  Slider->value(1);
Slider->do_callback();
}
void sequencer::cb_(Fl_Button* o, void* v) {
  ((sequencer*)(o->parent()->parent()->user_data()))->cb__i(o,v);
}

void sequencer::cb_Slider_i(Fl_Slider* o, void*) {
  char tmp[6];
rmgmo->cas=(int)o->value();
bzero(tmp,sizeof(tmp));
sprintf(tmp,"%d",rmgmo->cas);
Casi->copy_label(tmp);
if (SongF.MasterT)  rmgmo->BuscaTempo();
else 
{ 
if(SongF.bpm != 0 ) 
 rmgmo->bpm=SongF.bpm;
else rmgmo->bpm=120;
}
 
 
STempo->value(rmgmo->bpm);
}
void sequencer::cb_Slider(Fl_Slider* o, void* v) {
  ((sequencer*)(o->parent()->parent()->user_data()))->cb_Slider_i(o,v);
}

void sequencer::cb_SSTST_i(Fl_Button* o, void*) {
  rmgmo->splay=(int)o->value();

if (rmgmo->splay)
{
prepara();
rmgmo->ostart();
}
else
{
rmgmo->ostop();
rmgmo->tapaga=1;
};
}
void sequencer::cb_SSTST(Fl_Button* o, void* v) {
  ((sequencer*)(o->parent()->parent()->user_data()))->cb_SSTST_i(o,v);
}

void sequencer::cb_Casi_i(Fl_Box*, void*) {
  if (rmgmo->sic)
{
 char tmp[12];
 bzero(tmp,sizeof(tmp));
 sprintf(tmp,"%d",rmgmo->scompas); 
 rmgmo->sic=0;
 Bar->copy_label(tmp);
 Slider->value(rmgmo->cas);
 Slider->do_callback();
}

if (rmgmo->cc1)
{
  rmgmo->cc1=0;
  NomChord->copy_label(rmgmo->NombreAcorde);
}

if (rmgmo->finito)
{
  rmgmo->finito=0;
  SSTST->value(0);
  SSTST->do_callback();
}

if(rmgmo->MTempo)
 {
   STempo->value(rmgmo->MTempo);
   rmgmo->MTempo=0;
 }
 
if (rmgmo->CNStyle)
{
  rmgmo->CNStyle=0;
  NomStyle->copy_label(rmgmo->nStyle.Name);
}


if (rmgmo->CNPattern)
{
   rmgmo->CNPattern=0;
   NomPattern->copy_label(rmgmo->nStyle.Pattern[rmgmo->Variacion].Name);
};
}
void sequencer::cb_Casi(Fl_Box* o, void* v) {
  ((sequencer*)(o->parent()->parent()->user_data()))->cb_Casi_i(o,v);
}

void sequencer::cb_MTempoTrack_i(Fl_Button* o, void*) {
  SongF.MasterT = (int) o->value();
}
void sequencer::cb_MTempoTrack(Fl_Button* o, void* v) {
  ((sequencer*)(o->parent()->parent()->user_data()))->cb_MTempoTrack_i(o,v);
}

void sequencer::cb_TempoTrackBrowser_i(Fl_Browser* o, void*) {
  int i = (int) o->value();
WTTBar->value(SongF.TemT[i].bar);
WTTBlack->value(SongF.TemT[i].black);
WTTTempo->value(SongF.TemT[i].tempo);
}
void sequencer::cb_TempoTrackBrowser(Fl_Browser* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_TempoTrackBrowser_i(o,v);
}

void sequencer::cb_Modify_i(Fl_Button*, void*) {
  if (CheckTempoValues()) return;

char temp[64];
int i = (int) TempoTrackBrowser->value();
SongF.TemT[i].bar = (int) WTTBar->value();
SongF.TemT[i].black = (int) WTTBlack->value();
SongF.TemT[i].tempo = (int) WTTTempo->value();
bzero(temp,sizeof(temp));
sprintf(temp, "B-%03d-%d T-%03d",SongF.TemT[i].bar,SongF.TemT[i].black,SongF.TemT[i].tempo);
TempoTrackBrowser->text(i,temp);
}
void sequencer::cb_Modify(Fl_Button* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Modify_i(o,v);
}

void sequencer::cb_Delete1_i(Fl_Button*, void*) {
  int i = (int) TempoTrackBrowser->value();
if (i != 1)
{
TempoTrackBrowser->remove(i);
rmgmo->BorraTiempo(i);
};
}
void sequencer::cb_Delete1(Fl_Button* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Delete1_i(o,v);
}

void sequencer::cb_Add_i(Fl_Button*, void*) {
  if (CheckTempoValues()) return;

char temp[64];
int i = 1;
i = rmgmo->BuscaPosTempo((int)WTTBar->value(),(int)WTTBlack->value());

if (i==0) 
{
fl_message("Sorry Track Full");
return;
}

rmgmo->InsertaTiempo(i);
SongF.TemT[i].bar = (int) WTTBar->value();
SongF.TemT[i].black = (int) WTTBlack->value();
SongF.TemT[i].tempo = (int) WTTTempo->value();
bzero(temp,sizeof(temp));
sprintf(temp, "B-%03d-%d Tempo=%03d",SongF.TemT[i].bar,SongF.TemT[i].black, SongF.TemT[i].tempo);
TempoTrackBrowser->insert(i,temp);
TempoTrackBrowser->select(i);
}
void sequencer::cb_Add(Fl_Button* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Add_i(o,v);
}

void sequencer::cb_Clear_i(Fl_Button*, void*) {
  char temp[64];
TempoTrackBrowser->clear();
memset(SongF.TemT, 0 , sizeof SongF.TemT);

 SongF.TemT[1].bar = 1;
 SongF.TemT[1].black = 1;
 SongF.TemT[1].tempo = (int) STempo->value();

bzero(temp,sizeof(temp));
sprintf(temp, "B-%03d-%d Tempo=%03d",SongF.TemT[1].bar,SongF.TemT[1].black, SongF.TemT[1].tempo);
TempoTrackBrowser->add(temp);
TempoTrackBrowser->select(1);
}
void sequencer::cb_Clear(Fl_Button* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Clear_i(o,v);
}

void sequencer::cb_Close1_i(Fl_Button*, void*) {
  WTT->hide();
WTT->clear();
delete WTT;
}
void sequencer::cb_Close1(Fl_Button* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Close1_i(o,v);
}

void sequencer::cb_EditSeqwin_i(Fl_Double_Window*, void*) {
  EditSeqwin->hide();
EditSeqwin->clear();
delete EditSeqwin;
}
void sequencer::cb_EditSeqwin(Fl_Double_Window* o, void* v) {
  ((sequencer*)(o->user_data()))->cb_EditSeqwin_i(o,v);
}

void sequencer::cb_Cancel_i(Fl_Button*, void*) {
  EditSeqwin->do_callback();
}
void sequencer::cb_Cancel(Fl_Button* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Cancel_i(o,v);
}

void sequencer::cb_Ok_i(Fl_Button*, void*) {
  Hazlo();
EditSeqwin->do_callback();
}
void sequencer::cb_Ok(Fl_Button* o, void* v) {
  ((sequencer*)(o->parent()->user_data()))->cb_Ok_i(o,v);
}

sequencer::sequencer(RMGMO *rmgmo_) {
  Fl::visual(FL_DOUBLE|FL_INDEX);
Fl::visual(FL_RGB);
rmgmo=rmgmo_;
make_window();
stygmseqwin->position(x,y);
labelwin();

int x,y,w,h;

static const char *pepe [] ={"stygmorgan"};

int argc=1;
char **argv= (char **) pepe;

Fl_Preferences stygmorgan (Fl_Preferences::USER, WEBSITE, PACKAGE);

stygmorgan.get("sequencerwinX",x,4);
stygmorgan.get("sequencerwinY",y,29);
stygmorgan.get("sequencerwinW",w,800);
stygmorgan.get("sequencerwinH",h,600);

stygmseqwin->resize(x,y,w,h);

stygmseqwin->icon((char *)p);

stygmseqwin->show(argc,argv);


void * v=Casi;

Fl::add_timeout(1.0/500.0,tick,v);
}

void sequencer::tick(void* v) {
  Fl_Box *o = (Fl_Box*)v;

o->do_callback();

Fl::repeat_timeout(1.0/500.0,tick,v);
}

Fl_Double_Window* sequencer::make_window() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = stygmseqwin = new Fl_Double_Window(800, 600);
    w = o;
    o->callback((Fl_Callback*)cb_stygmseqwin, (void*)(this));
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 800, 25);
      o->menu(menu_);
    }
    { Fl_Group* o = new Fl_Group(0, 25, 800, 40);
      o->box(FL_DOWN_BOX);
      { Fl_Input* o = Titulo = new Fl_Input(40, 30, 225, 30, gettext("Title"));
        o->labelsize(11);
        o->callback((Fl_Callback*)cb_Titulo);
      }
      { Fl_Value_Input* o = STempo = new Fl_Value_Input(745, 30, 45, 30, gettext("Tempo"));
        o->color(FL_FOREGROUND_COLOR);
        o->labelsize(11);
        o->minimum(20);
        o->maximum(300);
        o->step(1);
        o->value(120);
        o->textsize(19);
        o->textcolor(1);
        o->callback((Fl_Callback*)cb_STempo);
      }
      o->end();
    }
    { Fl_Group* o = Displays = new Fl_Group(0, 465, 800, 135);
      o->box(FL_DOWN_BOX);
      { Fl_Browser* o = BroSty = new Fl_Browser(5, 480, 205, 115, gettext("Styles"));
        o->type(1);
        o->box(FL_FLAT_BOX);
        o->labelsize(11);
        o->align(FL_ALIGN_TOP);
      }
      { Fl_Browser* o = BroPat = new Fl_Browser(215, 480, 125, 115, gettext("Patterns"));
        o->box(FL_FLAT_BOX);
        o->labelsize(11);
        o->align(FL_ALIGN_TOP);
      }
      { Fl_Button* o = new Fl_Button(560, 565, 30, 30, gettext("@|<"));
        o->callback((Fl_Callback*)cb_);
        o->align(96);
      }
      { Fl_Slider* o = Slider = new Fl_Slider(595, 565, 205, 30);
        o->type(5);
        o->selection_color(FL_FOREGROUND_COLOR);
        o->labelsize(11);
        o->minimum(1);
        o->maximum(128);
        o->step(1);
        o->callback((Fl_Callback*)cb_Slider);
        o->align(FL_ALIGN_TOP_LEFT);
      }
      { Fl_Button* o = SSTST = new Fl_Button(710, 515, 85, 45, gettext("Start/Stop"));
        o->type(1);
        o->color((Fl_Color)215);
        o->selection_color((Fl_Color)3);
        o->labelsize(12);
        o->callback((Fl_Callback*)cb_SSTST);
      }
      { Fl_Box* o = Casi = new Fl_Box(710, 480, 40, 30, gettext("1"));
        o->box(FL_DOWN_BOX);
        o->color(FL_FOREGROUND_COLOR);
        o->selection_color(FL_FOREGROUND_COLOR);
        o->labelsize(18);
        o->labelcolor((Fl_Color)1);
        o->callback((Fl_Callback*)cb_Casi);
        o->align(72|FL_ALIGN_INSIDE);
      }
      { Fl_Box* o = Bar = new Fl_Box(755, 480, 40, 30, gettext("1"));
        o->box(FL_DOWN_BOX);
        o->color(FL_FOREGROUND_COLOR);
        o->labelsize(18);
        o->labelcolor((Fl_Color)1);
        o->align(FL_ALIGN_RIGHT|FL_ALIGN_INSIDE);
      }
      { Fl_Browser* o = BroChord = new Fl_Browser(350, 480, 95, 115, gettext("Chords"));
        o->labelsize(11);
        o->align(FL_ALIGN_TOP);
      }
      { Fl_Box* o = new Fl_Box(710, 465, 40, 15, gettext("Cell"));
        o->labelsize(11);
      }
      { Fl_Box* o = new Fl_Box(755, 465, 40, 15, gettext("Bar"));
        o->labelsize(11);
      }
      { Fl_Box* o = NomChord = new Fl_Box(560, 520, 145, 40, gettext("C"));
        o->box(FL_DOWN_BOX);
        o->color(FL_FOREGROUND_COLOR);
        o->labelsize(20);
        o->labelcolor((Fl_Color)1);
        o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
      }
      { Fl_Button* o = MTempoTrack = new Fl_Button(455, 565, 95, 30, gettext("Tempo Track"));
        o->type(1);
        o->color((Fl_Color)215);
        o->selection_color((Fl_Color)3);
        o->labelsize(12);
        o->callback((Fl_Callback*)cb_MTempoTrack);
      }
      { Fl_Box* o = NomStyle = new Fl_Box(450, 470, 255, 45);
        o->box(FL_DOWN_BOX);
        o->color(FL_FOREGROUND_COLOR);
        o->labelsize(20);
        o->labelcolor((Fl_Color)1);
        o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
      }
      { Fl_Box* o = NomPattern = new Fl_Box(450, 520, 105, 40, gettext("Fill In AB"));
        o->box(FL_DOWN_BOX);
        o->color(FL_FOREGROUND_COLOR);
        o->labelsize(20);
        o->labelcolor((Fl_Color)1);
        o->align(FL_ALIGN_CENTER|FL_ALIGN_INSIDE);
      }
      o->end();
    }
    { ElScroll* o = Scr = new ElScroll(0, 65, 800, 400);
      o->type(7);
      o->box(FL_NO_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color(FL_BACKGROUND_COLOR);
      o->labeltype(FL_NORMAL_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor(FL_FOREGROUND_COLOR);
      o->align(FL_ALIGN_TOP);
      o->when(FL_WHEN_RELEASE);
      o->end();
      Fl_Group::current()->resizable(o);
    }
    o->size_range(800, 600);
    o->end();
  }
  int i;
char tmp[64];



for (i=0;i<rmgmo->numstyles;i++)
{
 bzero(tmp,sizeof(tmp));
 sprintf(tmp,"%d - %s",i+1,rmgmo->StyleNom[i].Name);
 BroSty->add(tmp);
 }
 
for (i=0; i<=33; i++) BroChord->add(rmgmo->ChN[i].Nom);

MTempoTrack->value(SongF.MasterT);
Slider->value(rmgmo->cas);
Slider->do_callback();
Titulo->value(SongF.title);

GeneraScroll();
  return w;
}

void sequencer::song_call(Fl_Input* o, void* v) {
  ((sequencer*)(o->parent()->parent()->parent()->user_data()))->song_call_i(o,v);
}

inline void sequencer::song_call_i(Fl_Input* o, void*) {
  long long kd = (long long) o->user_data();

if (kd <= 128)
{
 if (rmgmo->CheckChord((char *) o->value())== 1 ) strcpy(S[kd].ch1,(char *) o->value());
 else
 saca_error(1);
 return;
} 
 
 
 
 
if ((kd > 128) && (kd <=256))
{
 if (rmgmo->CheckChord((char *) o->value())== 1 ) strcpy(S[kd-128].ch2,(char *) o->value());
 else
  saca_error(1);
 return;
}



if ((kd > 768) && (kd <=896))
{
 strcpy(S[kd-768].go_to,(char *) o->value());
 return;
}



if ((kd > 1152) && (kd <=1280))
{
 if (rmgmo->CheckChord((char *) o->value())== 1 )  strcpy(S[kd-1152].ch3,(char *) o->value());
else
  saca_error(1);
 return;
}





if ((kd > 1280) && (kd <=1408)) 
{
 if (rmgmo->CheckChord((char *) o->value())== 1 )  strcpy(S[kd-1280].ch4,(char *) o->value());
else
  saca_error(1);
 return;
}






if ((kd > 1664) && (kd <=1792)) strcpy(S[kd-1664].go_af,(char *) o->value());
}

void sequencer::song_call1(Fl_Value_Input* o, void* v) {
  ((sequencer*)(o->parent()->parent()->parent()->user_data()))->song_call1_i(o,v);
}

void sequencer::song_call1_i(Fl_Value_Input* o, void*) {
  long long kd = (long long) o->user_data();
int j;


if ((kd > 896) && (kd <=1024))
{
 S[kd-896].times = (int) o->value();
 return;
} 


if ((kd > 1024) && (kd <=1152))
{
 j = kd -1024;
 S[j].style = (int) o->value();
 S[j].pattern=1;

if (rmgmo->splay) return;

rmgmo->Estilo=(int)o->value();
rmgmo->readstyle(rmgmo->Estilo);
BroSty->value(rmgmo->Estilo);
MetePats();


 for ( int t=0; t<o->parent()->children(); t++ ) 
  {          
    Fl_Widget *w = o->parent()->child(t);
    
    long long temp = (long long) w->user_data();
    
    if (temp ==(4096+j))
      { 
        Fl_Value_Input* k;
        k =  (Fl_Value_Input*) w; 
        k->value(S[j].pattern);
      
      }  
   }

int t1=j;


while ((t1)<=128)
     {
     if ((t1>j) && (S[t1].style != 0 )) break; 
     
       Fl_Group * g = (Fl_Group*) Scr->child(t1-1);
    
          for ( int t=1; t<21; t++ )  
                {
                 Fl_Widget *w = g->child(t);

                 long long temp1 = (long long) w->user_data();    
              
                 if (temp1 ==(1280+t1))
                   {
                      switch(rmgmo->divisor)
                           {
                            case 4:
                              w->activate();
                              break;
                            case 5:
                              w->activate();
                              break;
                            default:
                              w->deactivate();
                            } 
                   }    
       
                if (temp1 ==(1152+t1))
                  {
                     switch(rmgmo->divisor)
                         {
                            case 2:
                             w->deactivate();
                             break;
                            case 6:
                             w->deactivate();
                             break;
                             default:
                             w->activate();
                         } 
                   }    
  
                }
           
      t1++;  
     }   
    



return;

}








if ((kd > 1792) && (kd <=1920))
 {
   S[kd-1792].atimes = (int) o->value();
   return;
 }  









if ((kd > 4096) && (kd <=4224)) 
{
S[kd-4096].pattern = (int) o->value();

if(rmgmo->splay) return;

if (S[kd-4096].style != 0) 
{
rmgmo->readstyle(S[kd-4096].style);
BroSty->value(S[kd-4096].style);
}
else
for (int i=kd-4096; i>0; i--)
{
  if (S[i].style != 0)
   {
     rmgmo->readstyle(S[i].style);
     BroSty->value(S[i].style);
     break;
    }   
}

MetePats();
if ((BroPat->size()>0 ) && ((int)o->value()<=BroPat->size()))
BroPat->value((int)o->value());
}
}

void sequencer::song_call2(Fl_Button* o, void* v) {
  ((sequencer*)(o->parent()->parent()->parent()->user_data()))->song_call2_i(o,v);
}

inline void sequencer::song_call2_i(Fl_Button* o, void*) {
  int i;
long long kd = (long long) o->user_data();
if ((kd > 256) && (kd <=384))
{
 for(i=1; i<=128; i++)
  { 
   if ((S[i].a != 0) && (i != (kd -256)))
     {
       fl_alert("Another 'A' point is selected. Please Correct.");
       o->value(0);
       S[kd-256].a = (int) o->value();
       return;
     }
  }
 
  S[kd-256].a = (int) o->value();
  return;
}



if ((kd > 384) && (kd <=512)) 
{
 for(i=1; i<=128; i++)
  { 
   if ((S[i].b != 0) && (i != (kd-384)))
     {
       fl_alert("Another 'B' point is selected. Please Correct.");
       o->value(0);
       S[kd-384].b = (int) o->value();
       return;
     }
  }

S[kd-384].b = (int) o->value();
return; 
}




if ((kd > 512) && (kd <=640))
{
  for(i=1; i<=128; i++)
  { 
   if ((S[i].c != 0) && (i != (kd -512)))
     {
       fl_alert("Another 'C' point is selected. Please Correct.");
       o->value(0);
       S[kd-512].c = (int) o->value();
       return;
     }
  }

 S[kd-512].c = (int) o->value();
 return;
}




if ((kd > 640) && (kd <=768))
{
 for(i=1; i<=128; i++)
  { 
   if ((S[i].d != 0) && (i != (kd-640)))
     {
       fl_alert("Another 'D' point is selected. Please Correct.");
       o->value(0);
        S[kd-640].d = (int) o->value();
       return;
     }
  }
 S[kd-640].d = (int) o->value();
 return;
}






if ((kd > 3500) && (kd <=3628))
{
 for(i=1; i<=128; i++)
  { 
   if ((S[i].e != 0) && (i != (kd-3500)))
     {
       fl_alert("Another 'E' point is selected. Please Correct.");
       o->value(0);
       S[kd-3500].e = (int) o->value();
       return;
     }
  }
 S[kd-3500].e = (int) o->value();
 return;

}





if ((kd > 3700) && (kd <=3828))
{
 for(i=1; i<=128; i++)
  { 
   if ((S[i].f != 0) && (i != (kd-3700)))
     {
       fl_alert("Another 'F' point is selected. Please Correct.");
       o->value(0);
       S[kd-3700].f = (int) o->value();
       return;
     }
  }
 S[kd-3700].f = (int) o->value();
 return;
}





if ((kd > 1920) && (kd <=2048))
{
 for(i=1; i<=128; i++)
  { 
   if ((S[i].fin != 0) && (i != (kd-1920)))
     {
       fl_alert("Another 'End' point is selected. Please Correct.");
       o->value(0);
       S[kd-1920].fin = (int) o->value();
       return;
     }
  }
 S[kd-1920].fin = (int) o->value();
 return;
}




if ((kd > 2048) && (kd <=2176))
{

 
 if (S[kd-2048].ar16) 
	 { 
	 o->value(0);
   	 return;
 	 }
 	 else S[kd-2048].ar8 = (int) o->value();
 return;
 }




if ((kd > 2176) && (kd <=2304))
{
 
if (S[kd-2176].ar8)
	{
 	 o->value(0);
 	 return;
	}
else S[kd-2176].ar16 = (int) o->value();
return;
}



if ((kd > 3100) && (kd <=3228))
{

 
 if (S[kd-3100].ar16a) 
	 { 
	 o->value(0);
   	 return;
 	 }
 	 else S[kd-3100].ar8a = (int) o->value();
  return;    
 }




if ((kd > 3300) && (kd <=3428))
{
 
if (S[kd-3300].ar8a)
	{
 	 o->value(0);
 	 return;
	}
else S[kd-3300].ar16a = (int) o->value();

}
}

void sequencer::GeneraScroll() {
  int i,x,y,k;
char tmp[64];
int num=0;

Scr->clear();
   
 for(i=1; i<=128; i++)
 
{  
 
  x = (((i-1) % 4) * 200)+ 1;  
  
 if (i < 5 ) y = 1; else  y = (((i-1)/ 4)  * 124) + 1; 
  
  
  num++;
  
  bzero(tmp,sizeof(tmp));
  sprintf(tmp,"%d",i);
    
            
      Fl_Group* ob = new Fl_Group( x , y, 199, 124);
       
      ob->box(FL_THIN_UP_BOX);
      ob->color(52);
      ob->labelsize(9);
      ob->labelcolor(88);
      ob->align(FL_ALIGN_BOTTOM_LEFT|FL_ALIGN_INSIDE);
      ob->copy_label(tmp);
      k=1000+i;
      ob->user_data((void *) i);
      ob->begin();
      
      Fl_Input* oin1 = new Fl_Input( x+1, y+1, 48,50);
      oin1->box(FL_THIN_DOWN_BOX);
      oin1->color(23);
      oin1->textcolor(88);
      oin1->user_data((void*) num);
      oin1->value(S[num].ch1);
      oin1->callback((Fl_Callback *)song_call);
      ob->add(oin1);
  
      Fl_Input* oin2 = new Fl_Input( x+50, y+1, 48,50);
      oin2->box(FL_THIN_DOWN_BOX);
      oin2->color(23);
      oin2->textcolor(88);
      oin2->user_data((void*) (128 + num));
      oin2->value(S[num].ch2);
      oin2->callback((Fl_Callback *)song_call);
      ob->add(oin2);
  
      Fl_Input* oin3 = new Fl_Input( x+99, y+1, 48,50);
      oin3->box(FL_THIN_DOWN_BOX);
      oin3->color(23);
      oin3->textcolor(88);
      oin3->user_data((void*) (1152 + num));
      oin3->value(S[num].ch3);
      oin3->callback((Fl_Callback *)song_call);
      ob->add(oin3);
 
      Fl_Input* oin4 = new Fl_Input( x+148, y+1, 48,50);
      oin4->box(FL_THIN_DOWN_BOX);
      oin4->color(23);
      oin4->textcolor(88);
      oin4->user_data((void*) (1280 + num));
      oin4->value(S[num].ch4);
      oin4->callback((Fl_Callback *)song_call);
      ob->add(oin4);     
      
       
            
      Fl_Button* but1 = new Fl_Button(x+27, y+98, 12,20,"A");
      but1->type(1);
      but1->box(FL_PLASTIC_UP_BOX);
      but1->selection_color(2);
      but1->labelsize(10);
      but1->user_data((void*) (256 + num));
      but1->value(S[num].a);
      but1->callback((Fl_Callback *)song_call2);
      ob->add(but1);
      
      Fl_Button* but2 = new Fl_Button(x+40, y+98, 12,20,"B");
      but2->type(1);
      but2->box(FL_PLASTIC_UP_BOX);
      but2->selection_color(2);
      but2->labelsize(10);
      but2->user_data((void*) (384 + num));
      but2->value(S[num].b);
      but2->callback((Fl_Callback *)song_call2);
      ob->add(but2);
      
      Fl_Button* but3 = new Fl_Button(x+53, y+98, 12,20,"C");
      but3->type(1);
      but3->box(FL_PLASTIC_UP_BOX);
      but3->selection_color(2);
      but3->labelsize(10);
      but3->user_data((void*) (512 + num));
      but3->value(S[num].c);
      but3->callback((Fl_Callback *)song_call2);
      ob->add(but3);
      
      Fl_Button* but4 = new Fl_Button(x+66, y+98, 12,20,"D");
      but4->type(1);
      but4->box(FL_PLASTIC_UP_BOX);
      but4->selection_color(2);
      but4->labelsize(10);
      but4->user_data((void*) (640 + num));
      but4->value(S[num].d);
      but4->callback((Fl_Callback *)song_call2);
      ob->add(but4);
      
      Fl_Button* but5 = new Fl_Button(x+79, y+98, 12,20,"E");
      but5->type(1);
      but5->box(FL_PLASTIC_UP_BOX);
      but5->selection_color(2);
      but5->labelsize(10);
      but5->user_data((void*) (3500 + num));
      but5->value(S[num].e);
      but5->callback((Fl_Callback *)song_call2);
      ob->add(but5);
      
      Fl_Button* but6 = new Fl_Button(x+92, y+98, 12,20,"F");
      but6->type(1);
      but6->box(FL_PLASTIC_UP_BOX);
      but6->selection_color(2);
      but6->labelsize(10);
      but6->user_data((void*) (3700 + num));
      but6->value(S[num].f);
      but6->callback((Fl_Callback *)song_call2);
      ob->add(but6);
      
      
     Fl_Input* oin5 = new Fl_Input(x+140, y+98, 12, 20, "To");
      oin5->box(FL_FLAT_BOX);
      oin5->labelsize(10);
      oin5->align(FL_ALIGN_LEFT);
      oin5->color(222);
      oin5->textcolor(88);
      oin5->user_data((void*) (768 + num));
      oin5->value(S[num].go_to);
      oin5->callback((Fl_Callback *)song_call);
      ob->add(oin5);

      Fl_Value_Input* val1 = new Fl_Value_Input(x+173, y+98, 20, 20,"Rp.");
      val1->box(FL_FLAT_BOX);
      val1->labelsize(10);
      val1->align(FL_ALIGN_LEFT);
      val1->color(222);
      val1->maximum(99);
      val1->step(1);
      val1->user_data((void*) (896 + num));
      val1->value(S[num].times);
      val1->callback((Fl_Callback *)song_call1);

      ob->add(val1);

     Fl_Input* oin6 = new Fl_Input(x+140, y+76, 12, 20, "To");
      oin6->box(FL_FLAT_BOX);
      oin6->labelsize(10);
      oin6->textcolor(88);
      oin6->align(FL_ALIGN_LEFT);
      oin6->color(222);
      oin6->user_data((void*) (1664 + num));
      oin6->value(S[num].go_af);
      oin6->callback((Fl_Callback *)song_call);

      ob->add(oin6);

      Fl_Value_Input* val4 = new Fl_Value_Input(x+173, y+76, 20, 20,"At.");
      val4->box(FL_FLAT_BOX);
      val4->labelsize(10);
      val4->align(FL_ALIGN_LEFT);
      val4->color(222);
      val4->maximum(99);
      val4->step(1);
      val4->user_data((void*) (1792 + num));
      val4->value(S[num].atimes);
      val4->callback((Fl_Callback *)song_call1);
      ob->add(val4);
 
 
 
 
 
 
 
     Fl_Value_Input* val2 = new Fl_Value_Input(x+22, y+76, 25, 20,"Sty.");
      val2->box(FL_FLAT_BOX);
      val2->labelsize(10);
      val2->align(FL_ALIGN_LEFT);
      val2->color(222);
      val2->maximum(rmgmo->numstyles);
      val2->step(1);
      val2->user_data((void*) (1024 + num));
      val2->value(S[num].style);
      val2->callback((Fl_Callback *)song_call1);

      ob->add(val2);
      
     Fl_Value_Input* val3 = new Fl_Value_Input(x+68, y+76, 20, 20,"Pat.");
      val3->box(FL_FLAT_BOX);
      val3->labelsize(10);
      val3->align(FL_ALIGN_LEFT);
      val3->color(222);
      val3->maximum(21);
      val3->step(1);
      val3->user_data((void*) (4096 + num));
      val3->value(S[num].pattern);
      val3->callback((Fl_Callback *)song_call1);

      ob->add(val3);
      
      
      Fl_Button* but8 = new Fl_Button(x+170, y+52, 12,20,"8");
      but8->type(1);
      but8->box(FL_FLAT_BOX);
      but8->color(28);
      but8->selection_color(2);
      but8->labelsize(11);
      but8->user_data((void*) (2048 + num));
      but8->value(S[num].ar8);
      but8->callback((Fl_Callback *)song_call2);

      ob->add(but8);
      
      Fl_Button* but16 = new Fl_Button(x+184, y+52, 12,20,"16");
      but16->type(1);
      but16->box(FL_FLAT_BOX);
      but16->color(28);
      but16->selection_color(2);
      but16->labelsize(11);
      but16->user_data((void*) (2176 + num));
      but16->value(S[num].ar16);
      but16->callback((Fl_Callback *)song_call2);

      Fl_Button* but8a = new Fl_Button(x+72, y+52, 12,20,"8");
      but8a->type(1);
      but8a->box(FL_FLAT_BOX);
      but8a->color(28);
      but8a->selection_color(2);
      but8a->labelsize(11);
      but8a->user_data((void*) (3100 + num));
      but8a->value(S[num].ar8a);
      but8a->callback((Fl_Callback *)song_call2);

      ob->add(but8a);
      
      Fl_Button* but16a = new Fl_Button(x+86, y+52, 12,20,"16");
      but16a->type(1);
      but16a->box(FL_FLAT_BOX);
      but16a->color(28);
      but16a->selection_color(2);
      but16a->labelsize(11);
      but16a->user_data((void*) (3300 + num));
      but16a->value(S[num].ar16a);
      but16a->callback((Fl_Callback *)song_call2);




      ob->add(but16);
      
      Fl_Button* butX = new Fl_Button(x+1, y+52, 26,22,"End");
      butX->type(1);
      butX->color(28);
      butX->box(FL_FLAT_BOX);
      butX->selection_color(2);
      butX->labelsize(10);
      butX->user_data((void*) (1920 + num));
      butX->value(S[num].fin);
      butX->callback((Fl_Callback *)song_call2);
      ob->add(butX);
      
      
      ob->end(); 
      
      Scr->add_resizable(*ob);
      Scr->resize(Scr->x(),Scr->y(),Scr->h(),Scr->w());
      
      
}

int t1=1;


while ((t1)<=128)
     {
     if (S[t1].style != 0 ) rmgmo->readstyle(S[t1].style); 
     
       Fl_Group * g = (Fl_Group*) Scr->child(t1-1);
    
          for ( int t=1; t<21; t++ )  
                {
                 Fl_Widget *w = g->child(t);

                 long long temp= (long long) w->user_data();
              
                 if ( temp ==(1280+t1))
                   {
                      switch(rmgmo->divisor)
                           {
                            case 4:
                              w->activate();
                              break;
                            case 5:
                              w->activate();
                              break;
                            default:
                              w->deactivate();
                            } 
                   }    
       
                   
       
                if (temp ==(1152+t1))
                  {
                     switch(rmgmo->divisor)
                         {
                            case 2:
                             w->deactivate();
                             break;
                            case 6:
                             w->deactivate();
                             break;
                             default:
                             w->activate();
                         } 
                   }    
  
                }
           
      t1++;  
     }   
    

Scr->redraw();
Fl::flush();
Scr->position(0,0);
}

void sequencer::GuardaPrefs() {
  Fl_Preferences stygmorgan (Fl_Preferences::USER, WEBSITE, PACKAGE);

stygmorgan.set("sequencerwinX",stygmseqwin->x());
stygmorgan.set("sequencerwinY",stygmseqwin->y());
stygmorgan.set("sequencerwinW",stygmseqwin->w());
stygmorgan.set("sequencerwinH",stygmseqwin->h());
}

void sequencer::NewSong() {
  memset(S,0 ,sizeof S);
memset(&SongF, 0, sizeof S);
GeneraScroll();
Titulo->value("");
STempo->value(120);
Slider->value(1);
Slider->do_callback();
MTempoTrack->value(0);
}

void sequencer::prepara() {
  int vari=1;
int i;

 rmgmo->rela=1.0;
 rmgmo->lppq=1; 
 
if (S[rmgmo->cas].style != 0)
{ rmgmo->Estilo=S[rmgmo->cas].style;
 rmgmo->readstyle(rmgmo->Estilo);
 rmgmo->CNStyle=1;
 rmgmo->CNPattern=1;
} 
else
{
for (i=rmgmo->cas;i>=1;i--)
{
if (S[i].style != 0)
{
 rmgmo->Estilo=S[i].style;
 rmgmo->readstyle(rmgmo->Estilo);
 rmgmo->CNStyle=1;
 rmgmo->CNPattern=1;
 break;
}
} 
}
rmgmo->bpm = (int)STempo->value();
if (SongF.MasterT)
{
 rmgmo->BuscaTempo();
 STempo->value(rmgmo->bpm); 
}
rmgmo->set_tempo();

if(S[rmgmo->cas].pattern != 0) vari=S[rmgmo->cas].pattern;
else
{
for (i=rmgmo->cas;i>=1;i--)
{
if(S[i].pattern != 0)
{
 vari=S[i].pattern;
 break;
}
}
} 

rmgmo->PonPatron(vari);
rmgmo->CNPattern=1;
rmgmo->MiraAcorde(rmgmo->cas,1);
rmgmo->BuscaRepes();
}

Fl_Double_Window* sequencer::prepara_WTT() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = WTT = new Fl_Double_Window(285, 325, gettext("Tempo Track"));
    w = o;
    o->color(FL_LIGHT2);
    o->user_data((void*)(this));
    { Fl_Browser* o = TempoTrackBrowser = new Fl_Browser(5, 5, 150, 315);
      o->type(2);
      o->textsize(12);
      o->callback((Fl_Callback*)cb_TempoTrackBrowser);
    }
    { Fl_Value_Input* o = WTTBar = new Fl_Value_Input(240, 25, 40, 25, gettext("Bar"));
      o->labelsize(11);
      o->minimum(1);
      o->maximum(4000);
      o->step(1);
      o->value(1);
      o->textsize(12);
    }
    { Fl_Value_Input* o = WTTTempo = new Fl_Value_Input(240, 85, 40, 25, gettext("Tempo"));
      o->labelsize(11);
      o->minimum(20);
      o->maximum(300);
      o->step(1);
      o->value(120);
      o->textsize(12);
    }
    { Fl_Button* o = new Fl_Button(170, 165, 110, 30, gettext("Modify"));
      o->box(FL_UP_FRAME);
      o->labelsize(12);
      o->callback((Fl_Callback*)cb_Modify);
      o->align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE);
    }
    { Fl_Value_Input* o = WTTBlack = new Fl_Value_Input(240, 55, 40, 25, gettext("Quarter Note"));
      o->labelsize(11);
      o->minimum(1);
      o->maximum(4);
      o->step(1);
      o->value(1);
      o->textsize(12);
    }
    { Fl_Button* o = new Fl_Button(170, 200, 110, 30, gettext("Delete"));
      o->box(FL_UP_FRAME);
      o->labelsize(12);
      o->callback((Fl_Callback*)cb_Delete1);
      o->align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE);
    }
    { Fl_Button* o = new Fl_Button(170, 130, 110, 30, gettext("Add"));
      o->box(FL_UP_FRAME);
      o->labelsize(12);
      o->callback((Fl_Callback*)cb_Add);
      o->align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE);
    }
    { Fl_Button* o = new Fl_Button(170, 235, 110, 30, gettext("Clear All"));
      o->box(FL_UP_FRAME);
      o->labelsize(12);
      o->callback((Fl_Callback*)cb_Clear);
      o->align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE);
    }
    { Fl_Button* o = new Fl_Button(170, 290, 110, 30, gettext("Close"));
      o->color((Fl_Color)27);
      o->labelsize(12);
      o->callback((Fl_Callback*)cb_Close1);
      o->align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE);
    }
    o->end();
  }
  int i;
char temp[128];
   
    WTTBar->value(SongF.TemT[1].bar);
    WTTBlack->value(SongF.TemT[1].black);
    WTTTempo->value(SongF.TemT[1].tempo);  
    TempoTrackBrowser->clear();

for (i=1; i<200; i++)
{
 if ((int)SongF.TemT[i].bar == 0 ) break;
 bzero(temp,sizeof(temp));
 sprintf(temp, "B-%03d-%d Tempo=%03d",SongF.TemT[i].bar,SongF.TemT[i].black, SongF.TemT[i].tempo);
 TempoTrackBrowser->add(temp); 

}

TempoTrackBrowser->select(1);
  return w;
}

int sequencer::CheckTempoValues() {
  if (((int) WTTBlack->value() > 4) || ((int) WTTBlack->value() < 1))
{
 fl_message("Sorry quarter note (1-4) only");
 return(1);
}
if (((int) WTTTempo->value() > 300) || ((int) WTTTempo->value() < 20))
{
 fl_message("Sorry Tempo (20-300) only");
 return(1);
}

return(0);
}

void sequencer::saca_error(int num) {
  switch (num)
  {
      case 1:
           fl_alert("Sorry but not seems a valid chord");
           break;
   }
}

Fl_Double_Window* sequencer::PreparaEdit(int imenufunc) {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = EditSeqwin = new Fl_Double_Window(250, 175);
    w = o;
    o->callback((Fl_Callback*)cb_EditSeqwin, (void*)(this));
    { Fl_Button* o = new Fl_Button(35, 125, 85, 30, gettext("Cancel"));
      o->callback((Fl_Callback*)cb_Cancel);
    }
    { Fl_Button* o = new Fl_Button(140, 125, 85, 30, gettext("Ok"));
      o->callback((Fl_Callback*)cb_Ok);
    }
    { Fl_Value_Input* o = From = new Fl_Value_Input(65, 20, 35, 25, gettext("From:"));
      o->labelsize(11);
      o->minimum(1);
      o->maximum(128);
      o->step(1);
      o->value(1);
    }
    { Fl_Value_Input* o = To = new Fl_Value_Input(175, 20, 35, 25, gettext("To:"));
      o->labelsize(11);
      o->minimum(1);
      o->maximum(128);
      o->step(1);
      o->value(1);
    }
    { Fl_Value_Input* o = Destination = new Fl_Value_Input(115, 70, 35, 25, gettext("Destination:"));
      o->labelsize(11);
      o->minimum(1);
      o->maximum(128);
      o->step(1);
      o->value(1);
    }
    o->end();
  }
  switch (imenufunc)
    {
       case 1:
           EditSeqwin->copy_label("Copy");
           Destination->show();
           break;
    
       case 2:
           EditSeqwin->copy_label("Delete");
           Destination->hide();
           break;
           
       case 3:
           EditSeqwin->copy_label("Move");
           Destination->show();
           break;    
    
    
    
    }
    
    rmgmo->imenu=imenufunc;
    
    EditSeqwin->hide();
    EditSeqwin->position(30,30);
    
static const char *pepe [] ={"stygmorgan"};

int argc=1;
char **argv= (char **) pepe;

EditSeqwin->icon((char *)p);
    
EditSeqwin->show(argc,argv);
  return w;
}

void sequencer::Hazlo() {
  int i;
int k=0;
int desde=(int)From->value();
int hasta=(int)To->value();
int hacia=(int)Destination->value();
int cuantos=hasta-desde+1;



switch(rmgmo->imenu)
{
        case 1:
         
        for (i=desde;i<=hasta; i++)   
           { 
          
            S[hacia+k]=S[i];
            k++; 
           }
         
         
        break;
        
        
        case 2:
        
        for (i=desde;i<=hasta; i++)   
           { 
             
              memset( &S[i], 0, sizeof S[0]);
           }
           
        
        break;
        
        
        
        case 3:
        
        for(i=1;i<=128;i++) SongF.S[i]=S[i];
        
        
        for (i=desde;i<=hasta; i++) 
           {
          S[hacia+k]=SongF.S[i];
          k++; 
          if (i<hacia) memset( &S[i], 0, sizeof S[0]);
          if (i >(hacia+cuantos)) memset( &S[i], 0, sizeof S[0]);   
           }
        
        
        
 }
 
 GeneraScroll();
}

void sequencer::MetePats() {
  int i;
char tmp[32];
BroPat->clear();

for (i=1; i<rmgmo->nStyle.numpat; i++)

{ 
bzero(tmp,sizeof(tmp));
sprintf(tmp,"%d - %s",i,rmgmo->nStyle.Pattern[i].Name);
BroPat->add(tmp);
}
}

void sequencer::labelwin() {
  char temp[128];

sprintf(temp, "%s %s - sequencer - %s",PACKAGE,VERSION,SongF.title);
stygmseqwin->copy_label(temp);
}

int sequencer::CheckForExport() {
  int i=rmgmo->ChecaExporta();

if (i==0) return(0);

switch(i)
{
  case 2:
     fl_alert("Please select and 'end' point");  
     break;
  case 3:
      fl_alert("Please select a style for the first bar");
         
 }        
         
         
return(1);
}
